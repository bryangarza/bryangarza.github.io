<!DOCTYPE html>
<html>
<head>
<!-- 2016-02-19 Fri 09:39 -->
<meta  charset="utf-8">
<meta  name="viewport" content="width=device-width, initial-scale=1">
<title>Automated Theorem Proving Work Log</title>
<meta  name="generator" content="Org-mode">
<meta  name="author" content="Bryan Garza">
<meta  name="description" content="Learning about automated theorem proving"
>
<meta  name="keywords" content="automated theorem proving">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="./css/styles.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<h1 class="title"><a href="http://bryangarza.github.io">val bryan : sushi -> emacs -> code </a></h1>
</div>
<div id="content">
<header><h1 class="title"><a href="./automated-theorem-proving-work-log.html">Automated Theorem Proving Work Log</a><span> </span><span class="timestamp-wrapper"><span class="timestamp">(February 12, 2016)</span></span></h1></header>

<div id="outline-container-orgheadline9" class="outline-2">
<h2 id="orgheadline9"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1"><span class="section-number-3">1.1</span> What is logical reasoning?</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Logical reasoning is all about abstracting forms of argument, and making sense
of them without taking into account assumptions about the properties of the
objects we are reasoning about.
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2"><span class="section-number-3">1.2</span> Calculemus!</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Leibniz wanted there to be a system whereby one could translate anything into a
universal language (<i>characteristica universalis</i>), and then decide on whether the
claims are true via a calculus of reasoning (<i>calculus ratiocinator</i>).
</p>

<p>
Even though it would be a long time before computing machines made this sort of
system possible, some early calculating machines were built, including one by
Leibniz that could do multiplication.
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">1.3</span> Symbolism</h3>
<div class="outline-text-3" id="text-1-3">
<p>
It&rsquo;s important to choose a symbolic notation that makes it easier to reason
about the logic, same as mathematical notation improved our ability to process
calculations. Symbolic notation is also unambiguous, an important property
missing from everyday language.
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">1.4</span> Boole&rsquo;s algebra of logic</h3>
<div class="outline-text-3" id="text-1-4">
<p>
After algebra was created, Boolean invented Boolean logic, molding his notation
to conform to the algebraic laws used in mathematics. By doing this he was able
to harness an existing framework and not have to formulate everything from
scratch. Some early machines for performing Boolean calculations were created
in the 1700 and 1800s.
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5"><span class="section-number-3">1.5</span> Syntax and semantics</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Syntax is the grammar of the language, with which we know we are forming well
constructed expressions. The semantics tell us the meaning of the expressions in
the language. &ldquo;Translated into linguistic jargon, choosing an interpretation
amounts exactly to giving a semantics to the language.&rdquo; (pg. 10)
</p>

<p>
Metalogic is reasoning about a logic system.
</p>

<p>
You can take the concrete syntax of an expression, its literal symbolic
representation, and express it better using an abstract expression. The book
gives an example of a tree (AST) being abstract syntax. It&rsquo;s pretty common to
convert between the concrete and the abstract, usually by writing a parser and
prettyprinter.
</p>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6"><span class="section-number-3">1.6</span> Symbolic computation and OCaml</h3>
<div class="outline-text-3" id="text-1-6">
<p>
This chapter just explains how to write a parse arithmetic expressions and
simplify them OCaml &#x2013; super easy. It essentially boils down to writing a sum
type that encompasses all the different symbols, and then a recursive function
that matches on the structure of the <code>Expr</code> type and combines terms.
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7"><span class="section-number-3">1.7</span> Parsing</h3>
<div class="outline-text-3" id="text-1-7">
<p>
First you have to do lexing, which is breaking down the string expression into
tokens, then convert the tokens into an AST. The example lexer just scans left
to right, matching on different types of symbols. I think it might be better to
write the parser with the Menhir library. Anyways, parsing is not really the
important part of the theorem prover anyways, so an efficient implementation
isn&rsquo;t really needed. It&rsquo;s not like we&rsquo;re parsing massive expressions anyways.
</p>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8"><span class="section-number-3">1.8</span> Prettyprinting</h3>
<div class="outline-text-3" id="text-1-8">
<p>
Prettyprinting amounts to pattern matching on different symbols and printing its
terms with some extra notation, such as parentheses, to aid readability. This
chapter also briefly explains how to add our printer to the OCaml REPL so that
certain types are passed through that printer instead of the default.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-2">
<h2 id="orgheadline16"><span class="section-number-2">2</span> Propositional logic</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">2.1</span> The syntax of propositional logic</h3>
<div class="outline-text-3" id="text-2-1">
<p>
We&rsquo;re going to build up our propositional logic representation using the
constant propositions <code>False</code> and <code>True</code>, atomic formula <code>Atom p</code>, unary operator <code>Not</code>,
and binary connectives <code>And</code>, <code>Or</code>, <code>Imp</code>, and <code>Iff</code>.
</p>

<p>
Our type:
</p>
<div class="org-src-container">

<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a formula</span> <span style="color: #a52a2a;">=</span>
  <span style="color: #a52a2a;">|</span> <span style="color: #000000; background-color: #ffffff;">False</span>
  <span style="color: #a52a2a;">|</span> <span style="color: #000000; background-color: #ffffff;">Atom</span> <span style="color: #a020f0;">of</span> 'a
  <span style="color: #a52a2a;">|</span> <span style="color: #000000; background-color: #ffffff;">Not</span> <span style="color: #a020f0;">of</span> 'a formula
  <span style="color: #a52a2a;">|</span> <span style="color: #000000; background-color: #ffffff;">And</span> <span style="color: #a020f0;">of</span> 'a formula <span style="color: #a52a2a;">*</span> 'a formula
  <span style="color: #a52a2a;">|</span> <span style="color: #000000; background-color: #ffffff;">Or</span> <span style="color: #a020f0;">of</span> 'a formula <span style="color: #a52a2a;">*</span> 'a formula
  <span style="color: #a52a2a;">|</span> <span style="color: #000000; background-color: #ffffff;">Imp</span> <span style="color: #a020f0;">of</span> 'a formula <span style="color: #a52a2a;">*</span> 'a formula
  <span style="color: #a52a2a;">|</span> <span style="color: #000000; background-color: #ffffff;">Iff</span> <span style="color: #a020f0;">of</span> 'a formula <span style="color: #a52a2a;">*</span> 'a formula
  <span style="color: #a52a2a;">|</span> <span style="color: #000000; background-color: #ffffff;">Forall</span> <span style="color: #a020f0;">of</span> string <span style="color: #a52a2a;">*</span> 'a formula
  <span style="color: #a52a2a;">|</span> <span style="color: #000000; background-color: #ffffff;">Exists</span> <span style="color: #a020f0;">of</span> string <span style="color: #a52a2a;">*</span> 'a formula
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11"><span class="section-number-3">2.2</span> The semantics of propositional logic</h3>
<div class="outline-text-3" id="text-2-2">
<p>
This chapter goes into how to write an <code>eval</code> function that takes an expression
and reduces it, as well as a function to print a truth table for an expression.
</p>

<p>
In the next chapter we&rsquo;re going to go into more detail about <i>quantifiers</i>, that
is, &ldquo;for all <i>x</i>&rdquo;, to be explicit about which properties apply universally.
</p>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12"><span class="section-number-3">2.3</span> Validity, satisfiability, and tautology</h3>
<div class="outline-text-3" id="text-2-3">
<p>
&ldquo;We say that a valuation <i>v</i> <i>satisfies</i> a formula <i>p</i> if <code>eval p v = true</code>.&rdquo;
</p>

<p>
Book gives definitions for tautology (logically valid), satisfiable, and
unsatisfiable/contradiction.
</p>

<p>
&ldquo;Substituting in tautologies yields a tautology.&rdquo;
</p>
</div>
</div>
<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">2.4</span> The De Morgan laws, adequacy and duality</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The De Morgan laws show the equivalence between 2 different expressions, and
there are other equivalences out there as well&#x2026; &ldquo;once we have an adequate set
of connectives, we can find formulas whose semantics correspond to any of the
other 12 truth-functions as well&rdquo; (pg. 48).
</p>

<p>
There&rsquo;s an explanation of duality, in which <code>And</code>&rsquo;s are swapped with <code>Or</code>&rsquo;s, and
<code>True</code>&rsquo;s with <code>False</code>&rsquo;s.
</p>
<div class="org-src-container">

<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">dual</span><span style="color: #a0522d;"> fm</span> <span style="color: #a52a2a;">=</span>
  <span style="color: #a020f0;">match</span> fm <span style="color: #a020f0;">with</span>
    <span style="color: #000000; background-color: #ffffff;">False</span>    <span style="color: #a52a2a;">-&gt;</span> <span style="color: #000000; background-color: #ffffff;">True</span>
  <span style="color: #a52a2a;">|</span> <span style="color: #000000; background-color: #ffffff;">True</span>     <span style="color: #a52a2a;">-&gt;</span> <span style="color: #000000; background-color: #ffffff;">False</span>
  <span style="color: #a52a2a;">|</span> <span style="color: #000000; background-color: #ffffff;">Atom</span><span style="color: #707183;">(</span>p<span style="color: #707183;">)</span>  <span style="color: #a52a2a;">-&gt;</span> fm
  <span style="color: #a52a2a;">|</span> <span style="color: #000000; background-color: #ffffff;">Not</span><span style="color: #707183;">(</span>p<span style="color: #707183;">)</span>   <span style="color: #a52a2a;">-&gt;</span> <span style="color: #000000; background-color: #ffffff;">Not</span><span style="color: #707183;">(</span>dual p<span style="color: #707183;">)</span>
  <span style="color: #a52a2a;">|</span> <span style="color: #000000; background-color: #ffffff;">And</span><span style="color: #707183;">(</span>p<span style="color: #a52a2a;">,</span>q<span style="color: #707183;">)</span> <span style="color: #a52a2a;">-&gt;</span> <span style="color: #000000; background-color: #ffffff;">Or</span><span style="color: #707183;">(</span>dual p<span style="color: #a52a2a;">,</span>dual q<span style="color: #707183;">)</span>
  <span style="color: #a52a2a;">|</span> <span style="color: #000000; background-color: #ffffff;">Or</span><span style="color: #707183;">(</span>p<span style="color: #a52a2a;">,</span>q<span style="color: #707183;">)</span>  <span style="color: #a52a2a;">-&gt;</span> <span style="color: #000000; background-color: #ffffff;">And</span><span style="color: #707183;">(</span>dual p<span style="color: #a52a2a;">,</span>dual q<span style="color: #707183;">)</span>
  <span style="color: #a52a2a;">|</span> _        <span style="color: #a52a2a;">-&gt;</span> <span style="color: #483d8b;">failwith</span> <span style="color: #8b2252;">"Formula involves connectives ==&gt; or &lt;=&gt;"</span>
</pre>
</div>

<p>
<b>Theorem 2.7: eval (dual p) v = not(eval p (not ◦ v)) for any valuation v.</b>
</p>

<p>
We can reason about this instead of constructing a formal proof. Replacing all
the terms with their opposites, as in the code above, then using De Morgan&rsquo;s law
to pull the negation outwards until we end with just one outermost negation,
exactly ¬(dual p).
</p>

<p>
<b>Corollary 2.8: If p and q are logically equivalent, so are dual p and dual q. If
p is a tautology then so is ¬(dual p).</b>
</p>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14"><span class="section-number-3">2.5</span> Simplification and negation normal forms</h3>
<div class="outline-text-3" id="text-2-5">
<p>
First section just shows some simplifications to remove <code>True</code> and <code>False</code>
constants, since they are always part of tautologies that &ldquo;justify an equivalence
with a simpler formula&rdquo;. This part is just preliminary for covering normal form.
</p>

<p>
The normal form covered is <i>negation normal form</i> (NNF), which only uses
and/or/true/false, no arrows, and negation only applied to atomic formulas.
</p>

<p>
By converting arrows to other connectives, and applying De Morgan&rsquo;s law in the
opposite direction as the previous section (that is, pushing negations inwards
to all the atomic formulas), we can reach NNF.
</p>

<p>
Since this expands exponentially, we can have an alternate simplification that
keeps the biconditional arrow but still pushes negation to atomic terms, using
a tautology such as ¬(p ⇔ q) ⇔ (¬p ⇔ q).
</p>

<p>
Even though this doesn&rsquo;t have as many nice properties as strict NNF, it still
has uses. With NNF, since <code>And</code> and <code>Or</code> are monotonic, we can deduce the
(anti)monotonicity property of an entire formula.
</p>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15"><span class="section-number-3">2.6</span> Disjunctive and conjunctive normal forms</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Disjunctive normal form takes NNF further by requiring that the expression be a
&ldquo;disjunction of conjunctions&rdquo;.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<a href="archive.html">Archive</a>
</div>
</body>
</html>
